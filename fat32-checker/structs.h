#pragma once
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <bitset>
#include <windows.h>  
#include <iomanip>
#include <sstream>
#include <unordered_set>
#include <codecvt>
#include <map>

#pragma pack(push, 1)
struct BootSector {
	uint8_t  jumpInstruction[3]; // Содержит команду для перехода (jump instruction), которая используется в самом начале загрузочного сектора для выполнения кода при старте. Это обычно команда перехода к основному коду загрузчика, который будет выполнять дальнейшую инициализацию.
	char     OEMName[8];         // имя производителя
	uint16_t bytesPerSector;     // Количество байтов в одном секторе
	uint8_t  sectorsPerCluster;  // Количество секторов в одном кластере.
	uint16_t reservedSectors;    // Количество зарезервированных секторов перед файловой системой. Обычно это количество секторов, которые используются для хранения метаданных файловой системы, например, для области загрузчика и таблицы FAT.
	uint8_t  numFATs;            // Количество таблиц FAT. В FAT32 всегда используется 2 таблицы FAT для избыточности и защиты данных. Обычно это значение равно 2.
	uint16_t rootDirEntries;     // Количество записей в корневой директории. Для FAT16 это значение ограничено, но для FAT32 эта информация уже не имеет смысла, так как файлы и каталоги корневой директории могут располагаться в кластерах, а не фиксированно в таблице записей.
	uint16_t totalSectors16;     // Общее количество секторов на диске. Для дисков, объем которых не превышает 32 МБ, используется это 16-битное поле. Для более больших дисков используется поле totalSectors32.
	uint8_t  mediaType;          // Тип носителя
	uint16_t sectorsPerFAT16;    // Для FAT16 это поле указывает количество секторов в одной таблице FAT. В FAT32 это поле не используется, но может содержать значение для совместимости.
	uint16_t sectorsPerTrack;    // Количество секторов в одном треке жесткого диска. Это значение используется для геометрии дисков в старых системах.
	uint16_t numHeads;           // Количество головок для чтения/записи на диске.
	uint32_t hiddenSectors;      // Количество скрытых секторов перед началом раздела. Это может быть полезно, если перед основным разделом находится зарезервированное пространство, например, для загрузчика или для других целей
	uint32_t totalSectors32;     // Общее количество секторов на диске. Это поле используется для больших дисков, объем которых превышает 32 МБ. В отличие от totalSectors16, которое ограничено 16 битами, это поле позволяет работать с более крупными носителями.

	// FAT32-specific fields     

	uint32_t sectorsPerFAT32;    // Количество секторов, занимаемых одной таблицей FAT в файловой системе FAT32. Это поле имеет значение только для FAT32
	uint16_t extFlags;           // Флаги, специфичные для FAT32. Например, могут использоваться для указания наличия нескольких кластерных цепочек.
	uint16_t fsVersion;          // Версия файловой системы FAT32. Обычно для FAT32 это будет 0x00 0x00, что указывает на стандартную версию.
	uint32_t rootCluster;        // Номер первого кластера корневой директории. В отличие от FAT16, где корневая директория имеет фиксированный размер и расположение, в FAT32 корневая директория может занимать несколько кластеров, и этот параметр указывает на первый кластер, где начинается корневая директория.
	uint16_t fsInfoSector;       // Сектор, в котором хранится информация о файловой системе, включая информацию о свободных кластерах.
	uint16_t backupBootSector;   // Сектор, где хранится резервная копия загрузочного сектора. Используется для восстановления при повреждении основного загрузочного сектора.
	uint8_t  reserved[12];       // Зарезервированные байты. Эти байты обычно не используются, но они должны быть заняты для обеспечения совместимости.
	uint8_t  driveNumber;        // Номер диска, на котором находится файловая система (например, номер для виртуального диска или для физического устройства).
	uint8_t  reserved1;          // Зарезервированное поле. Обычно не используется и оставлено для совместимости с более старыми версиями.
	uint8_t  bootSignature;      // Подпись для проверки валидности загрузочного сектора. Это поле обычно содержит значение 0x29, которое указывает, что сектора являются действительными.
	uint32_t volumeID;           // Уникальный идентификатор тома. Это поле используется для идентификации тома и может быть сгенерировано случайным образом.
	char     volumeLabel[11];    // Метка тома (Volume Label). Это строка, которая может содержать метку для раздела (например, "NO_NAME "). Это поле не является обязательным.
	char     fsType[8];          // Тип файловой системы. Например, для FAT32 здесь будет строка "FAT32 ".
};

struct DirEntry {
	uint8_t  name[11];           // Массив из 11 байт, который хранит имя файла или директории.
	uint8_t  attr;               // Атрибуты файла или директории. Это флаг, который может включать различные значения, такие как: 0x01 — атрибут "только для чтения" 0x02 — атрибут "скрытый файл"  0x04 — атрибут "системный файл"  0x08 — атрибут "метка тома" 0x10 — атрибут "директория" 0x20 — атрибут "архив"
	uint8_t  ntRes;              // Этот байт зарезервирован для использования в операционных системах, основанных на DOS. В современных системах его значение обычно игнорируется.
	uint8_t  crtTimeTenth;       // Десятая часть секунды при создании файла (значение от 0 до 99). Это поле дает точность до 10 миллисекунд.
	uint16_t crtTime;            // Время создания файла
	uint16_t crtDate;            // Дата создания файла
	uint16_t lstAccDate;         // Дата последнего доступа к файлу в таком же формате, как и для crtDate
	uint16_t fstClusHi;          // Старшая часть номера кластера первого кластера файла (старшие 16 бит). Для файлов, чьи данные не умещаются в одном кластере, эта часть указывает на номер первого кластера данных.
	uint16_t wrtTime;            // Время последней записи
	uint16_t wrtDate;            // Дата последней записи
	uint16_t fstClusLo;          // Младшая часть номера кластера первого кластера файла (младшие 16 бит).
	uint32_t fileSize;           // Размер файла в байтах.
};

struct LFNEntry {                // Эта структура описывает запись длинного имени файла, которое в FAT32 не может быть сохранено в одной записи DirEntry, поскольку FAT32 использует ограничение 8.3 для имени. 
	uint8_t order;               // Порядковый номер записи. Это значение определяет порядок, в котором части имени должны быть собраны. Оно начинается с младших значений и увеличивается для каждой новой записи LFN.
	uint16_t name1[5];           // Первые 5 символов длинного имени. Поскольку в FAT32 используется кодировка UTF-16, каждый символ занимает 2 байта.
	uint8_t attr;                // Атрибут записи, который всегда равен 0x0F для записи длинного имени.
	uint8_t type;                // Этот байт зарезервирован для использования в операционных системах, основанных на DOS, и обычно равен 0.
	uint8_t checksum;            // Контрольная сумма имени файла в формате 8.3. Это значение используется для проверки правильности собранного имени файла.
	uint16_t name2[6];           // Следующие 6 символов длинного имени, представленных в формате UTF-16.
	uint16_t zero;               // Два байта, которые всегда равны нулю. Это значение используется для выравнивания структуры.
	uint16_t name3[2];           // Последние два символа длинного имени, представленных в формате UTF-16.
};

#pragma pack(pop)



struct File {
	std::string name;
	std::string filename;
	std::string attr;

	uint8_t attr_int = 0;
	uint32_t firstClaster = 0;
	uint32_t fileSize = 0;
	uint16_t wrtTime = 0;
	uint16_t wrtDate = 0;

	// Метод для преобразования в строку
	std::string toString() const;

	// Перегрузка оператора вывода
	friend std::ostream& operator<<(std::ostream& os, const File& file) {
		std::string displayName = file.name;
		std::string displayfilename = file.filename;
		uint32_t displayfileSize = file.fileSize;
		uint32_t displayFirstClaster = file.firstClaster;
		os << "_________________________________________\n"
			<< "File: " << std::left << std::setw(30) << displayName << " \n"
			<< file.attr_int << "\n"
			<< "________________________________________|\n"
			<< "Path  " << displayfilename << "\n"
			<< "Size:      " << std::setw(10) << displayfileSize << " bytes \n"
			<< "First Cluster: " << displayFirstClaster << "\n"
			<< "Modified:  " << formatFatDateTime(file.wrtDate, file.wrtTime) << "\n"
			<< "_________________________________________|\n\n";

		return os;
	}

private:
	static std::string formatFatDateTime(uint16_t date, uint16_t time);
};
struct BrokenFileInfo {
	std::string filename;
	std::string errorMessage;
};

